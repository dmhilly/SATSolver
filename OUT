scala -cp classes DPLL tests/integration/sat/backjumpsimple.cnf
NOT TRIMMING UNIQUE VARS!!! CHANGE THIS!!!
Vars:List(-1, -1, -1, -1)
Clauses: x0 not(x1) not(x2) AND not(x0) not(x2) not(x3) AND not(x0) not(x2) x3 AND not(x0) x2 not(x3) AND not(x0) x2 x3 AND x1 x2 not(x3) AND x0 not(x1) x2 AND x0 x1 not(x2) 
Trying: (0,true)
Propogating:List(1, -1, -1, -1)
Trying: (1,true)
Propogating:List(1, 1, -1, -1)
Trying: (2,true)
Propogating:List(1, 1, 1, -1)
Found unit clause:not(x0) not(x2) not(x3) ; Literal: not(x3) 
Found unit clause:not(x0) not(x2) x3 ; Literal: x3 
Bad clause:not(x0) not(x2) not(x3) 
Running conflict analysis on implication graph: Nodes: { (0,true) (2,true) (3,false) (3,true) } Edges: { (2,true)->(3,false) (2,true)->(3,true) (0,true)->(3,false) (0,true)->(3,true) }
Found resolution clause: not(x2) not(x0) 
Added clause: not(x2) not(x0) 
Trying: (2,false)
Propogating:List(1, 1, 0, -1)
Found unit clause:not(x0) x2 not(x3) ; Literal: not(x3) 
Found unit clause:not(x0) x2 x3 ; Literal: x3 
Bad clause:not(x0) x2 not(x3) 
Running conflict analysis on implication graph: Nodes: { (0,true) (3,false) (2,false) (3,true) } Edges: { (0,true)->(3,false) (0,true)->(3,true) (2,false)->(3,true) (2,false)->(3,false) }
Found resolution clause: not(x0) x2 
Added clause: not(x0) x2 
Running conflict analysis on implication graph: Nodes: { (0,true) (3,false) (2,false) (3,true) } Edges: { (0,true)->(3,false) (0,true)->(3,true) (2,false)->(3,true) (2,false)->(3,false) }
Found resolution clause: not(x0) x2 
Backjumping
PRUNING List((0,true), (1,false))
Trying: (1,false)
Propogating:List(1, 0, -1, -1)
Found unit clause:not(x2) not(x0) ; Literal: not(x2) 
Found unit clause:not(x0) x2 ; Literal: x2 
Found unit clause:not(x0) not(x2) not(x3) ; Literal: not(x3) 
Found unit clause:not(x0) not(x2) x3 ; Literal: x3 
Bad clause:not(x2) not(x0) 
Bad clause:not(x0) not(x2) not(x3) 
Bad clause:not(x2) not(x0) 
Running conflict analysis on implication graph: Nodes: { (0,true) (2,true) (2,false) (3,false) (3,true) } Edges: { (2,true)->(3,false) (2,true)->(3,true) (0,true)->(3,false) (0,true)->(2,false) (0,true)->(2,true) (0,true)->(3,true) }
Found resolution clause: not(x0) not(x2) 
Added clause: not(x0) not(x2) 
Running conflict analysis on implication graph: Nodes: { (0,true) (2,true) (2,false) (3,false) (3,true) } Edges: { (2,true)->(3,false) (2,true)->(3,true) (0,true)->(3,false) (0,true)->(2,false) (0,true)->(2,true) (0,true)->(3,true) }
Found resolution clause: not(x0) not(x2) 
Backjumping
PRUNING List((0,false))
Trying: (0,false)
Propogating:List(0, -1, -1, -1)
Trying: (2,true)
Propogating:List(0, -1, 1, -1)
Found unit clause:x0 not(x1) not(x2) ; Literal: not(x1) 
Found unit clause:x0 x1 not(x2) ; Literal: x1 
Bad clause:x0 not(x1) not(x2) 
Running conflict analysis on implication graph: Nodes: { (1,true) (2,true) (1,false) (0,false) } Edges: { (2,true)->(1,true) (0,false)->(1,true) (0,false)->(1,false) (2,true)->(1,false) }
Found resolution clause: not(x2) x0 
Added clause: not(x2) x0 
Trying: (2,false)
Propogating:List(0, -1, 0, -1)
Found unit clause:x0 not(x1) x2 ; Literal: not(x1) 
Found unit clause:x1 x2 not(x3) ; Literal: not(x3) 
0 0 0 0 
SATISFIABLE
